import 'dart:convert';
import 'dart:io';

import 'package:fl_build/make.dart';
import 'package:fl_build/res.dart';

extension IterX<T> on Iterable<T> {
  T? firstWhereOrNull(bool Function(T) test) {
    for (final element in this) {
      if (test(element)) {
        return element;
      }
    }
    return null;
  }
}

Future<void> updateBuildData() async {
  print('Updating BuildData...');

  final moreJson = await () async {
    final file = File(MORE_BUILD_DATA_PATH);
    if (!await file.exists()) return <String, dynamic>{};
    final moreData = await file.readAsString();
    final commentRemoved = moreData.split('\n').where((line) {
      final trimmed = line.trim();
      return !trimmed.startsWith('//');
    }).join('\n');
    return json.decode(commentRemoved) as Map<String, dynamic>;
  }();
  final data = {
    'name': appName,
    'build': COMMIT_COUNT,
    'engine': await getFlutterVersion(),
    'buildAt': DateTime.now().toString().split('.').firstOrNull,
    'modifications': await getGitModificationCount(),
    ...moreJson,
  };
  print(JSON_ENCODER.convert(data));

  final buffer = StringBuffer();
  buffer.writeln('// This file is generated by make script. Do not edit.');
  buffer.writeln('');
  buffer.writeln('class ${makeCfg.buildDataClass} {');
  for (var entry in data.entries) {
    final type = entry.value.runtimeType;
    final value = json.encode(entry.value);
    buffer.writeln('  static const $type ${entry.key} = $value;');
  }
  buffer.writeln('}');
  await File(makeCfg.buildDataPath).writeAsString(buffer.toString());
}

Future<void> dartFormat() async {
  final result = await Process.run('dart', ['format', '.'], runInShell: true);
  print(result.stdout);
  if (result.exitCode != 0) {
    print(result.stderr);
    exit(1);
  }
}

Future<String> getFlutterVersion([int n = 1]) async {
  if (n > 3) return 'Unknown';
  final result = await Process.run('flutter', ['--version'], runInShell: true);
  final stdout = result.stdout as String;
  try {
    return stdout.split('\n')[0].split('â€¢')[0].split(' ')[1].trim();
  } catch (_) {
    return await getFlutterVersion(n + 1);
  }
}

Future<int> getGitModificationCount() async {
  final result =
      await Process.run('git', ['ls-files', '-mo', '--exclude-standard']);
  return (result.stdout as String)
      .split('\n')
      .where((line) => line.isNotEmpty)
      .length;
}

Future<void> installAppImageTool() async {
  if (!Platform.isLinux) return;
  final result = await Process.run('which', ['appimagetool']);
  if (result.exitCode == 0) return;

  const url = 'https://github.com/AppImage/appimagetool/releases/download/'
      'continuous/appimagetool-x86_64.AppImage';
  print('Downloading appimagetool...');
  await Process.run('wget', ['-O', 'appimagetool', url]);
  await Process.run('chmod', ['+x', 'appimagetool']);
}
